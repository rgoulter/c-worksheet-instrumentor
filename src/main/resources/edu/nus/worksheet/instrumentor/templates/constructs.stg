delimiters "$", "$"


primitiveFormatSpecifiers ::= [
  "char":"%c",
  "char *":"%s",
  "short":"%hd",
  "int":"%d",
  "long":"%ld",
  "float":"%g",
  "double":"%g",
  default: "%d" // probably anything else is int type?
]


// What headers may be needed;
// to be inserted at the beginning of the instrumented file.
preamble() ::= <<
$["stdio.h", "stdlib.h", "string.h", "setjmp.h", "signal.h"]:{header |#include <$header$>
}$
static jmp_buf buf;
static void catch_function(int signo) {
    longjmp(buf,1);
}
>>


lineDirective(lineNum) ::= <<
printf("LINE $lineNum$\\n");
if (setjmp(buf)) { // ASSUME setjmp buf is `buf`.
    printf("SEGFAULT\\n");
    exit(EXIT_SUCCESS);
}
if (signal(SIGSEGV, catch_function) == SIG_ERR) {
    fputs("An error occurred while setting a signal handler.\n", stderr);
    exit(EXIT_FAILURE);
}
>>


// buf has ptr, len, offset
declaration(buf, initLength = "8") ::= <<
int $buf.offset$ = 0, $buf.len$ = $initLength$;
char * $buf.ptr$ = (char*) malloc($buf.len$ * sizeof(char));
>>


checksize(buf, n) ::= <<
while (($buf.len$ - $buf.offset$) < $n$) {
    $buf.len$ *= 2;
    $buf.ptr$ = (char*) realloc($buf.ptr$, $buf.len$ * sizeof(char));
}
>>


append(buf, str) ::= <<
$checksize(buf, strlen(str))$
strcpy($buf.ptr$ + $buf.offset$, $str$);
$buf.offset$ += strlen($str$);
>>


output(buf, T) ::= "$(T.template)(buf, T)$"


// TODO: %d works only for ints; what about for other types? ST4's dictionary?
//       is Scala able to generate consistent types for anything we may want?
output_primitive(buf, T) ::= <<
{
  int n = snprintf(NULL, 0, "$primitiveFormatSpecifiers.(T.ctype)$", $T.id$); // Check
  $checksize(buf, "n")$
  sprintf($buf.ptr$ + $buf.offset$, "$primitiveFormatSpecifiers.(T.ctype)$", $T.id$); // Output Prim
  $buf.offset$ += n;
}
>>


output_pointer(buf, T) ::= <<
{
  int n = snprintf(NULL, 0, "%p", (void*)$T.id$);
  $checksize(buf, "n")$
  sprintf($buf.ptr$, "%p", (void*)$T.id$);
  $buf.offset$ += n;

  int tryOffset = $buf.offset$;
  if (!setjmp(buf)) {
    $append(buf, "\" = \"")$
    $if(T.of)$
    $output(buf, T.of)$
    $endif$
  } else {
    $buf.offset$ = tryOffset; // Dereference failed; go back.
    $buf.ptr$[$buf.offset$] = '\0';
  }
}
>>


// TODO: Better way to have an idx variable so it's "unique" among these constructions.
output_array(buf, T) ::= <<
$append(buf, "\"[\"")$
for (int $T.index$ = 0; $T.index$ < $T.n$; $T.index$++) {
    if ($T.index$ > 0) {
        $append(buf, "\", \"")$
    }
    
    $output(buf, T.of)$
}
$append(buf, "\"]\"")$
>>


output_struct(buf, T) ::= <<
$append(buf, "\"{\"")$
  $T.members : {m |
$append(buf, m.id:{x|"$x$"})$;
$append(buf, "\" = \"")$;
$output(buf, m)$
}; separator=append(buf, "\", \"")$
$append(buf, "\"}\"")$
>>


// output the constant text, not the value.
// e.g. FOO of enum { FOO, BAR }.
output_enum(buf, T) ::= <<
switch($T.id$) {
$T.constants:{c|  case $c$:
  $append(buf, c:{C|"$C$"})$
  break;
}$
}
>>